<!doctype html>
<html
  lang="en"
  class="mx-auto my-0 max-w-[1440px] scroll-pt-32 scroll-smooth overflow-x-hidden"
>
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    {% include "partials/meta-info.html" %} {% include
    "partials/google-fonts.html" %}
    <link
      rel="alternate"
      type="application/rss+xml"
      href="{{ site.url }}/feed.xml"
    />
    {% capture css %} {% include "css/styles.css" %} {% endcapture%}
    <link rel="stylesheet" href="/css/bookshop.css" />
    <link rel="stylesheet" href="/css/styles.css" />
    <style defer>
      {{ css  }}
    </style>    
    <script type="module" src="/assets/js/table-saw.js"></script>
    <script defer src="/assets/js/leaflet.js"></script>
    <script defer src="/assets/js/gesture-handling.js"></script>
    {{site.customCode.headCode}}
    {{customCode.headCode}}
  </head>
  {% include "partials/analytics.html" %} {% include
  "partials/watermark.html" %}
  <body
    data-umami-auto-track
    data-umami-scroll-thresholds="20,40,60,80,100"
    class="mx-4 sm:mx-10  flex flex-col h-screen text-{{site.color_group}}-textcolor bg-{{site.color_group}}-backgroundcolor text-lg "
  >
  
    {% include "partials/site-head.html" %}

    <main
      tabindex="-1"
      id="main-content"
      class="flex flex-1 flex-col [&>:last-child]:flex-1 mt-20"
      _='on load 
      measure #navbar height then set :height to it
      set :maincontent to the #main-content
      set :maincontent.style.marginTop to :height.height+"px"
      log :height.height
      end'
    >
      {% bookshop_include "hero" hero: hero %} {% bookshop_include "page"
      content_blocks: content_blocks %} {% block content %}{% endblock %}
    </main>
    {% include "partials/site-foot.html" %} 
    {% bookshop "util/textContrastScript"  %}
    {% mermaid_js %}
    <script>
      const inactive = tab => tab.classList.remove('active')
    const active = tab => tab.classList.add('active')
    const tabClick = tab => tab.addEventListener('click', listener)

    const listener = (event) => {
      // id for the clicked button
      const tabId = event.target.getAttribute('data-id')
      // the parent container's id
      const containerId = event.target.parentElement.parentElement.getAttribute('data-id')
      // syntax sugar for self
      const parentQuery = `.tabs-tabs-wrapper[data-id=${containerId}]`

      // Set everything in this parent container to inactive
      document.querySelectorAll(`${parentQuery} .tabs-tab-content`).forEach(inactive)
      document.querySelectorAll(`${parentQuery} .tabs-tabs-header button`).forEach(inactive)

      // Set the tab id's items to active
      document.querySelectorAll(`[data-id=${tabId}]`).forEach(active)
    }

    // Set it up for all my homies (multiple tabs)
    document.querySelectorAll('.tabs-tabs-header button').forEach(tabClick)
    </script>
    <script defer>
      // Calculate contrast ratio based on RGB values
      function calculateContrast(rgb) {
        var sum = Math.round(
          (parseInt(rgb[0]) * 299 +
            parseInt(rgb[1]) * 587 +
            parseInt(rgb[2]) * 114) /
            1000,
        );
        return sum > 128 ? "text-slate-950" : "text-white";
      }

      // Function to set foreground color based on contrast
      function setForegroundColor(element) {
        // Get RGB values from the element's style or data attribute
        var style = window.getComputedStyle(element);
        var backgroundColor = style.backgroundColor;
        var match = backgroundColor.match(/^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/);
        if (match) {
          var rgb = [
            parseInt(match[1]),
            parseInt(match[2]),
            parseInt(match[3]),
          ];
          var contrastClass = calculateContrast(rgb);
          element.classList.add(contrastClass);
        }
      }

      // Select elements with data-contrast="true" attribute and set foreground color
      document.addEventListener("DOMContentLoaded", function () {
        var elements = document.querySelectorAll('[data-contrast="true"]');
        elements.forEach(function (element) {
          setForegroundColor(element);
        });
      });
    </script>

    <script src="https://unpkg.com/hyperscript.org@0.9.11"></script>
    <script defer>
      var prevScrollpos = window.pageYOffset;
      window.onscroll = function () {
        var nav = document.getElementById("navbar");
        var currentScrollPos = window.pageYOffset;

        if (currentScrollPos > 250 && prevScrollpos < currentScrollPos) {
          nav.style.top = "-" + nav.offsetHeight + "px";
        } else if (
          currentScrollPos <= 250 ||
          prevScrollpos > currentScrollPos
        ) {
          nav.style.top = "0";
        }

        prevScrollpos = currentScrollPos;
      };
    </script>

  <script defer>

      /**
     * A lightweight youtube embed. Still should feel the same to the user, just MUCH faster to initialize and paint.
     *
     * Thx to these as the inspiration
     *   https://storage.googleapis.com/amp-vs-non-amp/youtube-lazy.html
     *   https://autoplay-youtube-player.glitch.me/
     *
     * Once built it, I also found these:
     *   https://github.com/ampproject/amphtml/blob/master/extensions/amp-youtube (ðŸ‘ðŸ‘)
     *   https://github.com/Daugilas/lazyYT
     *   https://github.com/vb/lazyframe
     */
    class LiteYTEmbed extends HTMLElement {
    connectedCallback() {
        this.videoId = this.getAttribute('videoid');
        this.thumbOnly = this.hasAttribute('thumbOnly');

        let playBtnEl = this.querySelector('.lty-playbtn');
        // A label for the button takes priority over a [playlabel] attribute on the custom-element
        this.playLabel = (playBtnEl && playBtnEl.textContent.trim()) || this.getAttribute('playlabel') || 'Play';

        this.dataset.title = this.getAttribute('title') || "";

        /**
         * Lo, the youtube poster image!  (aka the thumbnail, image placeholder, etc)
         *
         * See https://github.com/paulirish/lite-youtube-embed/blob/master/youtube-thumbnail-urls.md
         */
        if (!this.style.backgroundImage) {
          this.style.backgroundImage = `url("https://i.ytimg.com/vi/${this.videoId}/hqdefault.jpg")`;
          this.upgradePosterImage();
        }

        // Set up play button, and its visually hidden label
        if (!playBtnEl) {
            playBtnEl = document.createElement('button');
            playBtnEl.type = 'button';
            playBtnEl.classList.add('lty-playbtn');
            this.append(playBtnEl);
        }
        if (!playBtnEl.textContent) {
            const playBtnLabelEl = document.createElement('span');
            playBtnLabelEl.className = 'lyt-visually-hidden';
            playBtnLabelEl.textContent = this.playLabel;
            playBtnEl.append(playBtnLabelEl);
        }

        this.addNoscriptIframe();

        // for the PE pattern, change anchor's semantics to button
        if(playBtnEl.nodeName === 'A'){
            playBtnEl.removeAttribute('href');
            playBtnEl.setAttribute('tabindex', '0');
            playBtnEl.setAttribute('role', 'button');
            // fake button needs keyboard help
            playBtnEl.addEventListener('keydown', e => {
                if( e.key === 'Enter' || e.key === ' ' ){
                    e.preventDefault();
                    this.activate();
                }
            });
        }

        if(this.thumbOnly) {
          return;
        }
        // On hover (or tap), warm up the TCP connections we're (likely) about to use.
        this.addEventListener('pointerover', LiteYTEmbed.warmConnections, {once: true});
        this.addEventListener('focusin', LiteYTEmbed.warmConnections, {once: true});

        // Once the user clicks, add the real iframe and drop our play button
        // TODO: In the future we could be like amp-youtube and silently swap in the iframe during idle time
        //   We'd want to only do this for in-viewport or near-viewport ones: https://github.com/ampproject/amphtml/pull/5003
        this.addEventListener('click', this.activate);

        // Chrome & Edge desktop have no problem with the basic YouTube Embed with ?autoplay=1
        // However Safari desktop and most/all mobile browsers do not successfully track the user gesture of clicking through the creation/loading of the iframe,
        // so they don't autoplay automatically. Instead we must load an additional 2 sequential JS files (1KB + 165KB) (un-br) for the YT Player API
        // TODO: Try loading the the YT API in parallel with our iframe and then attaching/playing it. #82
        this.needsYTApi = this.hasAttribute("js-api") || navigator.vendor.includes('Apple') || navigator.userAgent.includes('Mobi');
    }

    /**
     * Add a <link rel={preload | preconnect} ...> to the head
     */
    static addPrefetch(kind, url, as) {
        const linkEl = document.createElement('link');
        linkEl.rel = kind;
        linkEl.href = url;
        if (as) {
            linkEl.as = as;
        }
        document.head.append(linkEl);
    }

    /**
     * Begin pre-connecting to warm up the iframe load
     * Since the embed's network requests load within its iframe,
     *   preload/prefetch'ing them outside the iframe will only cause double-downloads.
     * So, the best we can do is warm up a few connections to origins that are in the critical path.
     *
     * Maybe `<link rel=preload as=document>` would work, but it's unsupported: http://crbug.com/593267
     * But TBH, I don't think it'll happen soon with Site Isolation and split caches adding serious complexity.
     */
    static warmConnections() {
        if (LiteYTEmbed.preconnected) return;

        // The iframe document and most of its subresources come right off youtube.com
        LiteYTEmbed.addPrefetch('preconnect', 'https://www.youtube-nocookie.com');
        // The botguard script is fetched off from google.com
        LiteYTEmbed.addPrefetch('preconnect', 'https://www.google.com');

        // Not certain if these ad related domains are in the critical path. Could verify with domain-specific throttling.
        LiteYTEmbed.addPrefetch('preconnect', 'https://googleads.g.doubleclick.net');
        LiteYTEmbed.addPrefetch('preconnect', 'https://static.doubleclick.net');

        LiteYTEmbed.preconnected = true;
    }

    fetchYTPlayerApi() {
        if (window.YT || (window.YT && window.YT.Player)) return;

        this.ytApiPromise = new Promise((res, rej) => {
            var el = document.createElement('script');
            el.src = 'https://www.youtube.com/iframe_api';
            el.async = true;
            el.onload = _ => {
                YT.ready(res);
            };
            el.onerror = rej;
            this.append(el);
        });
    }

    /** Return the YT Player API instance. (Public L-YT-E API) */
    async getYTPlayer() {
        if(!this.playerPromise) {
            await this.activate();
        }

        return this.playerPromise;
    }

    async addYTPlayerIframe() {
        this.fetchYTPlayerApi();
        await this.ytApiPromise;

        const videoPlaceholderEl = document.createElement('div')
        this.append(videoPlaceholderEl);

        const paramsObj = Object.fromEntries(this.getParams().entries());

        this.playerPromise = new Promise(resolve => {
            let player = new YT.Player(videoPlaceholderEl, {
                width: '100%',
                videoId: this.videoId,
                playerVars: paramsObj,
                events: {
                    'onReady': event => {
                        event.target.playVideo();
                        resolve(player);
                    }
                }
            });
        });
    }

    // Add the iframe within <noscript> for indexability discoverability. See https://github.com/paulirish/lite-youtube-embed/issues/105
    addNoscriptIframe() {
        const iframeEl = this.createBasicIframe();
        const noscriptEl = document.createElement('noscript');
        // Appending into noscript isn't equivalant for mysterious reasons: https://html.spec.whatwg.org/multipage/scripting.html#the-noscript-element
        noscriptEl.innerHTML = iframeEl.outerHTML;
        this.append(noscriptEl);
    }

    getParams() {
        const params = new URLSearchParams(this.getAttribute('params') || []);
        params.append('autoplay', '1');
        params.append('playsinline', '1');
        return params;
    }

    async activate(){
        if (this.classList.contains('lyt-activated')) return;
        this.classList.add('lyt-activated');

        if (this.needsYTApi) {
            return this.addYTPlayerIframe(this.getParams());
        }

        const iframeEl = this.createBasicIframe();
        this.append(iframeEl);

        // Set focus for a11y
        iframeEl.focus();
    }

    createBasicIframe(){
        const iframeEl = document.createElement('iframe');
        iframeEl.width = 560;
        iframeEl.height = 315;
        // No encoding necessary as [title] is safe. https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html#:~:text=Safe%20HTML%20Attributes%20include
        iframeEl.title = this.playLabel;
        iframeEl.allow = 'accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture';
        iframeEl.allowFullscreen = true;
        // AFAIK, the encoding here isn't necessary for XSS, but we'll do it only because this is a URL
        // https://stackoverflow.com/q/64959723/89484
        iframeEl.src = `https://www.youtube-nocookie.com/embed/${encodeURIComponent(this.videoId)}?${this.getParams().toString()}`;
        return iframeEl;
    }

    /**
     * In the spirit of the `lowsrc` attribute and progressive JPEGs, we'll upgrade the reliable
     * poster image to a higher resolution one, if it's available.
     * Interestingly this sddefault webp is often smaller in filesize, but we will still attempt it second
     * because getting _an_ image in front of the user if our first priority.
     *
     * See https://github.com/paulirish/lite-youtube-embed/blob/master/youtube-thumbnail-urls.md for more details
     */
    upgradePosterImage() {
         // Defer to reduce network contention.
        setTimeout(() => {
            const webpUrl = `https://i.ytimg.com/vi_webp/${this.videoId}/sddefault.webp`;
            const img = new Image();
            img.fetchPriority = 'low'; // low priority to reduce network contention
            img.referrerpolicy = 'origin'; // Not 100% sure it's needed, but https://github.com/ampproject/amphtml/pull/3940
            img.src = webpUrl;
            img.onload = e => {
                // A pretty ugly hack since onerror won't fire on YouTube image 404. This is (probably) due to
                // Youtube's style of returning data even with a 404 status. That data is a 120x90 placeholder image.
                // â€¦ per "annoying yt 404 behavior" in the .md
                const noAvailablePoster = e.target.naturalHeight == 90 && e.target.naturalWidth == 120;
                if (noAvailablePoster) return;

                this.style.backgroundImage = `url("${webpUrl}")`;
            }
        }, 100);
    }
    }
    // Register custom element
    customElements.define('lite-youtube', LiteYTEmbed);
  </script>

  <script defer>
    class LiteVimeo extends (globalThis.HTMLElement ?? class {}) {
            /**
             * Begin pre-connecting to warm up the iframe load
             * Since the embed's network requests load within its iframe,
             *   preload/prefetch'ing them outside the iframe will only cause double-downloads.
             * So, the best we can do is warm up a few connections to origins that are in the critical path.
             *
             * Maybe `<link rel=preload as=document>` would work, but it's unsupported: http://crbug.com/593267
             * But TBH, I don't think it'll happen soon with Site Isolation and split caches adding serious complexity.
             */
            static _warmConnections() {
              if (LiteVimeo.preconnected) return;
              LiteVimeo.preconnected = true;
          
              // The iframe document and most of its subresources come right off player.vimeo.com
              addPrefetch('preconnect', 'https://player.vimeo.com');
              // Images
              addPrefetch('preconnect', 'https://i.vimeocdn.com');
              // Files .js, .css
              addPrefetch('preconnect', 'https://f.vimeocdn.com');
              // Metrics
              addPrefetch('preconnect', 'https://fresnel.vimeocdn.com');
            }
          
            connectedCallback() {
              this.videoId = this.getAttribute('videoid');
              this.thumbOnly = this.hasAttribute('thumbOnly');
          
              /**
               * Lo, the vimeo placeholder image!  (aka the thumbnail, poster image, etc)
               * We have to use the Vimeo API.
               */
              let { width, height } = getThumbnailDimensions(this.getBoundingClientRect());
              let devicePixelRatio = window.devicePixelRatio || 1;
              if (devicePixelRatio >= 2) devicePixelRatio *= .75;
              width = Math.round(width * devicePixelRatio);
              height = Math.round(height * devicePixelRatio);
          
              fetch(`https://vimeo.com/api/v2/video/${this.videoId}.json`)
                .then(response => response.json())
                .then(data => {
                  let thumbnailUrl = data[0].thumbnail_large;
                  thumbnailUrl = thumbnailUrl.replace(/-d_[\dx]+$/i, `-d_${width}x${height}`);
                  this.style.backgroundImage = `url("${thumbnailUrl}")`;
                });
          
              let playBtnEl = this.querySelector('.ltv-playbtn');
              // A label for the button takes priority over a [playlabel] attribute on the custom-element
              this.playLabel = (playBtnEl && playBtnEl.textContent.trim()) || this.getAttribute('playlabel') || 'Play video';
          
              if (!playBtnEl) {
                playBtnEl = document.createElement('button');
                playBtnEl.type = 'button';
                playBtnEl.setAttribute('aria-label', this.playLabel);
                playBtnEl.classList.add('ltv-playbtn');
                this.append(playBtnEl);
              }
              playBtnEl.removeAttribute('href');
              
              if (this.thumbOnly) {
                return;
              }
              // On hover (or tap), warm up the TCP connections we're (likely) about to use.
              this.addEventListener('pointerover', LiteVimeo._warmConnections, {
                once: true
              });
          
              // Once the user clicks, add the real iframe and drop our play button
              // TODO: In the future we could be like amp-youtube and silently swap in the iframe during idle time
              //   We'd want to only do this for in-viewport or near-viewport ones: https://github.com/ampproject/amphtml/pull/5003
              this.addEventListener('click', this.addIframe);
            }
          
            addIframe() {
              if (this.classList.contains('ltv-activated')) return;
              this.classList.add('ltv-activated');
          
              const iframeEl = document.createElement('iframe');
              iframeEl.width = 640;
              iframeEl.height = 360;
              // No encoding necessary as [title] is safe. https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html#:~:text=Safe%20HTML%20Attributes%20include
              iframeEl.title = this.playLabel;
              iframeEl.allow = 'fullscreen; accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture';
              // AFAIK, the encoding here isn't necessary for XSS, but we'll do it only because this is a URL
              // https://stackoverflow.com/q/64959723/89484
              iframeEl.src = `https://player.vimeo.com/video/${encodeURIComponent(this.videoId)}?autoplay=1`;
              this.append(iframeEl);
          
              // Set focus for a11y
              iframeEl.addEventListener('load', iframeEl.focus, { once: true });
            }
          }
          
          if (globalThis.customElements && !globalThis.customElements.get('lite-vimeo')) {
            globalThis.customElements.define('lite-vimeo', LiteVimeo);
          }
          
          /**
           * Add a <link rel={preload | preconnect} ...> to the head
           */
          function addPrefetch(kind, url, as) {
            const linkElem = document.createElement('link');
            linkElem.rel = kind;
            linkElem.href = url;
            if (as) {
              linkElem.as = as;
            }
            linkElem.crossorigin = true;
            document.head.append(linkElem);
          }
          
          /**
           * Get the thumbnail dimensions to use for a given player size.
           *
           * @param {Object} options
           * @param {number} options.width The width of the player
           * @param {number} options.height The height of the player
           * @return {Object} The width and height
           */
          function getThumbnailDimensions({ width, height }) {
            let roundedWidth = width;
            let roundedHeight = height;
          
            // If the original width is a multiple of 320 then we should
            // not round up. This is to keep the native image dimensions
            // so that they match up with the actual frames from the video.
            //
            // For example 640x360, 960x540, 1280x720, 1920x1080
            //
            // Round up to nearest 100 px to improve cacheability at the
            // CDN. For example, any width between 601 pixels and 699
            // pixels will render the thumbnail at 700 pixels width.
            if (roundedWidth % 320 !== 0) {
              roundedWidth = Math.ceil(width / 100) * 100;
              roundedHeight = Math.round((roundedWidth / width) * height);
            }
          
            return {
              width: roundedWidth,
              height: roundedHeight
            };
          }
  </script>
  <script>

    'use strict';

document.addEventListener('DOMContentLoaded', function () {
	const listener = new Listener();

	listener.decode = function () {
		// Decode plain text nodes
		const textElements = document.querySelectorAll('[data-rot20-text]');
		for (const el of textElements) {
			if (el.firstChild?.nodeType === Node.TEXT_NODE) {
				el.firstChild.nodeValue = rot20_7(el.firstChild.nodeValue);
			}
		}

		// Decode href attributes
		const linkElements = document.querySelectorAll('[data-rot20-href]');
		for (const el of linkElements) {
			const encodedHref = el.getAttribute('data-rot20-href');
			el.setAttribute('href', rot20_7(encodedHref));
		}
	};

	listener.on();
});

// ROT20 for letters, ROT7 for numbers
function rot20_7(str) {
	return str.replace(/[a-zA-Z0-9]/g, (char) => {
		const code = char.charCodeAt(0);

		// ROT20 for uppercase letters
		if (code >= 65 && code <= 90) {
			return String.fromCharCode(((code - 65 + 20) % 26) + 65);
		}

		// ROT20 for lowercase letters
		if (code >= 97 && code <= 122) {
			return String.fromCharCode(((code - 97 + 20) % 26) + 97);
		}

		// ROT7 for digits
		if (code >= 48 && code <= 57) {
			return String.fromCharCode(((code - 48 + 7) % 10) + 48);
		}

		return char;
	});
}

// Listener class
function Listener() {}

Listener.prototype.decode = null;

Listener.prototype.on = function () {
	this.listener = this.__onInteraction.bind(this);
	document.addEventListener('mouseenter', this.listener, true);
	document.addEventListener('focus', this.listener, true);
  document.addEventListener('scroll', this.listener, true);
};

Listener.prototype.off = function () {
	document.removeEventListener('mouseenter', this.listener, true);
	document.removeEventListener('focus', this.listener, true);
  document.removeEventListener('scroll', this.listener, true);
	delete this.listener;
};

Listener.prototype.__onInteraction = function () {
	this.off();
	this.decode();
};
  </script>
  <script defer>
/**
 * Scattered Gallery Class
 * Refactored to support component structures (Button + Dialog) AND Picture tags
 */
class ScatteredGallery {
    constructor(element) {
        this.container = element;
        
        const defaults = {
            photoSize: 599,
            borderSize: 10,
            photoShadow: 30,
            screen: true,
            scattering: true,
            arstr: 1,
            showInfo: true,
            infoStyle: 2,
            autoSlide: false,
            duration: 3
        };

        this.settings = { ...defaults };
        // Read data attributes
        for (const key in defaults) {
            const dataVal = this.container.dataset[key];
            if (dataVal !== undefined) {
                if(dataVal === "true") this.settings[key] = true;
                else if(dataVal === "false") this.settings[key] = false;
                else if(!isNaN(dataVal)) this.settings[key] = Number(dataVal);
                else this.settings[key] = dataVal;
            }
        }

        this.elements = [];
        this.activeIndex = -1;
        this.zIndexCounter = 100;
        this.autoSlideInterval = null;

        this.init();
    }

    init() {
        // PRESERVATION LOGIC:
        // We do not destroy innerHTML. We consume children and wrap them.
        
        // 1. Identify valid items (Buttons, Imgs, or Pictures) and move Dialogs to Body
        const rawChildren = Array.from(this.container.children);
        const scatterItems = [];
        let loaderElement = null;

        rawChildren.forEach(child => {
            if (child.tagName === 'DIALOG') {
                // CRITICAL: Move dialogs to body. 
                // Transforms on parent (the scatter div) will break fixed position of dialogs.
                document.body.appendChild(child); 
            } else if (child.classList.contains('ffka-loader')) {
                loaderElement = child;
            } else if (
                child.matches('img') || 
                child.matches('picture') || 
                child.matches('button') || 
                child.classList.contains('c-imageModal')
            ) {
                // This is a scatterable item
                scatterItems.push(child);
            }
        });

        // 2. Clear Container (The dialogs are safe in body, items are in memory)
        this.container.innerHTML = '';
        
        // Restore loader
        if(!loaderElement) {
            loaderElement = document.createElement('div');
            loaderElement.className = 'ffka-loader';
            loaderElement.innerHTML = '<div class="spinner"></div>';
        }
        this.container.appendChild(loaderElement);
        this.loader = loaderElement;

        // 3. Build Gallery
        this.buildGallery(scatterItems);
        this.addNavigation();
        
        // 4. Initial Layout
        setTimeout(() => {
            this.loader.classList.add('loaded');
            this.container.style.opacity = 1;
            this.scatterPhotos();
            
            // Randomly select one to bring to front
            const randIndex = Math.floor(Math.random() * this.elements.length);
            this.selectImage(randIndex);
            
            if(this.settings.autoSlide) this.startAutoSlide();
        }, 500);

        // Events
        let resizeTimer;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimer);
            resizeTimer = setTimeout(() => this.scatterPhotos(true), 100);
        });

        document.addEventListener('keydown', (e) => {
            if(this.container.matches(':hover')) {
                if(e.key === "ArrowLeft") this.prev();
                if(e.key === "ArrowRight") this.next();
            }
        });
    }

    buildGallery(items) {
        const fragment = document.createDocumentFragment();

        items.forEach((item, index) => {
            const wrapper = document.createElement('div');
            wrapper.className = 'photo-container';
            wrapper.dataset.index = index;

            const inner = document.createElement('div');
            inner.className = 'photo-inner';
            inner.style.padding = `${this.settings.borderSize}px`;

            // Append the actual DOM node (preserves events/hyperscript)
            inner.appendChild(item);

            // Add Info if it's a plain image or picture (Components usually handle their own info)
            // We only add the JS-generated info overlay if it is NOT a button/modal component
            const isInteractive = item.matches('button') || item.classList.contains('c-imageModal');
            
            if (this.settings.showInfo && !isInteractive) {
                // Find the IMG tag directly or nested within Picture
                const imgEl = item.tagName === 'IMG' ? item : item.querySelector('img');
                const alt = imgEl ? imgEl.alt : '';
                
                if(alt) {
                    const info = document.createElement('div');
                    info.className = `photo-info info-style-${this.settings.infoStyle}`;
                    info.innerHTML = `<span>${alt}</span>`;
                    inner.appendChild(info);
                }
            }

            wrapper.appendChild(inner);

            // Click Logic - INTERCEPTION
            // Use capture phase (true) to intercept clicks before they reach the button/modal trigger.
            wrapper.addEventListener('click', (e) => {
                if (this.activeIndex !== index) {
                    // Item is NOT currently selected:
                    // Stop event from reaching the child (button) to prevent modal opening.
                    e.stopPropagation(); 
                    e.preventDefault(); 
                    
                    // Select it instead.
                    this.selectImage(index);
                    this.stopAutoSlide();
                }
                // If it IS selected, we let the event fall through to the child button.
            }, true); // <--- Capture Phase is crucial here

            this.elements.push(wrapper);
            fragment.appendChild(wrapper);
        });

        this.container.appendChild(fragment);
    }

    addNavigation() {
        const prevBtn = document.createElement('div');
        prevBtn.className = 'sc-nav-arrow sc-prev';
        prevBtn.innerHTML = '<span class="arrow-icon"></span>';
        
        const nextBtn = document.createElement('div');
        nextBtn.className = 'sc-nav-arrow sc-next';
        nextBtn.innerHTML = '<span class="arrow-icon"></span>';

        prevBtn.addEventListener('click', (e) => { e.stopPropagation(); this.prev(); });
        nextBtn.addEventListener('click', (e) => { e.stopPropagation(); this.next(); });
        
        let touchStartX = 0;
        let touchEndX = 0;
        
        this.container.addEventListener('touchstart', (e) => {
            touchStartX = e.changedTouches[0].screenX;
        }, {passive: true});

        this.container.addEventListener('touchend', (e) => {
            touchEndX = e.changedTouches[0].screenX;
            this.handleSwipe();
        }, {passive: true});

        this.handleSwipe = () => {
            const threshold = 50;
            if (touchEndX < touchStartX - threshold) this.next();
            if (touchEndX > touchStartX + threshold) this.prev();
        };

        this.container.appendChild(prevBtn);
        this.container.appendChild(nextBtn);
    }

    scatterPhotos(preserveSelected = false) {
        const cw = this.container.offsetWidth;
        const ch = this.container.offsetHeight;
        const padding = this.settings.photoSize / 2;
        const safeW = cw - padding;
        const safeH = ch - padding;

        this.elements.forEach((el, index) => {
            if (preserveSelected && index === this.activeIndex) return;

            el.classList.remove('selected');
            
            const rX = Math.random() * (safeW - padding) + padding / 2;
            const rY = Math.random() * (safeH - padding) + padding / 2;
            
            let transform = '';
            const deg = this.randomInt(-20, 20);

            switch(this.settings.arstr) {
                case 1: transform = `rotate(${deg}deg) scale(0.6)`; break;
                case 2: transform = `scale(0.6)`; break;
                case 3: transform = `rotate(${deg}deg) perspective(500px) rotateY(${deg}deg) scale(0.6)`; break;
                case 4: transform = `perspective(500px) rotateY(${this.randomInt(-30, 30)}deg) scale(0.6)`; break;
                default: transform = `scale(0.6)`;
            }

            el.style.left = `${rX}px`;
            el.style.top = `${rY}px`;
            el.style.transform = transform;
            el.style.zIndex = Math.floor(Math.random() * 50);
            
            // Constrain Size
            // We search for img deeply (works for picture > img or button > picture > img)
            const innerImg = el.querySelector('img');
            if(innerImg) {
                innerImg.style.maxWidth = `${this.settings.photoSize}px`;
                innerImg.style.maxHeight = `${this.settings.photoSize}px`;
            }
        });

        if(preserveSelected && this.activeIndex > -1) {
            this.selectImage(this.activeIndex);
        }
    }

    selectImage(index) {
        if (index < 0 || index >= this.elements.length) return;
        
        if (this.activeIndex !== -1 && this.activeIndex !== index) {
            const prevEl = this.elements[this.activeIndex];
            prevEl.classList.remove('selected');
            const transform = this.settings.arstr === 2 ? 
                `scale(0.6)` : 
                `rotate(${this.randomInt(-20, 20)}deg) scale(0.6)`;
            prevEl.style.transform = transform;
            prevEl.style.zIndex = Math.floor(Math.random() * 50);
        }

        this.activeIndex = index;
        const el = this.elements[index];
        this.zIndexCounter++;
        el.style.zIndex = this.zIndexCounter;
        el.classList.add('selected');
    }

    next() {
        this.stopAutoSlide();
        let newIndex = this.activeIndex + 1;
        if (newIndex >= this.elements.length) newIndex = 0;
        this.selectImage(newIndex);
    }

    prev() {
        this.stopAutoSlide();
        let newIndex = this.activeIndex - 1;
        if (newIndex < 0) newIndex = this.elements.length - 1;
        this.selectImage(newIndex);
    }

    startAutoSlide() {
        this.autoSlideInterval = setInterval(() => {
            let newIndex = this.activeIndex + 1;
            if (newIndex >= this.elements.length) newIndex = 0;
            this.selectImage(newIndex);
        }, this.settings.duration * 1000);
    }

    stopAutoSlide() {
        if (this.autoSlideInterval) {
            clearInterval(this.autoSlideInterval);
            this.autoSlideInterval = null;
        }
    }

    randomInt(min, max) {
        return Math.floor(Math.random() * (max - min + 1) + min);
    }
}

// Init
document.addEventListener("DOMContentLoaded", () => {
    const galleries = document.querySelectorAll('[id^="ffka_sc_wrap"]');
    galleries.forEach(el => new ScatteredGallery(el));
});

  </script>
  <script defer>
(function(window) {
    "use strict";

    let counter = 0;
    const headCache = document.head;

    const BigText = {
        DEBUG_MODE: false,
        DEFAULT_MIN_FONT_SIZE_PX: null,
        DEFAULT_MAX_FONT_SIZE_PX: 2000,
        GLOBAL_STYLE_ID: 'bigtext-style',
        STYLE_ID: 'bigtext-id',
        LINE_CLASS_PREFIX: 'bigtext-line',
        EXEMPT_CLASS: 'bigtext-exempt',
        resizeListeners: {},

        supports: {
            wholeNumberFontSizeOnly: (function() {
                if (!('getComputedStyle' in window)) {
                    return true;
                }
                const test = document.createElement('div');
                Object.assign(test.style, {
                    position: 'absolute',
                    fontSize: '14.1px'
                });
                
                const firstScript = document.getElementsByTagName('script')[0];
                if (firstScript) {
                    firstScript.parentNode.insertBefore(test, firstScript);
                } else {
                    document.body.appendChild(test);
                }

                const computedStyle = window.getComputedStyle(test, null);
                const ret = computedStyle && computedStyle.getPropertyValue('font-size') === '14px';
                test.remove();
                return ret;
            })()
        },

        init: function() {
            if (!document.getElementById(BigText.GLOBAL_STYLE_ID)) {
                const globalStyles = [
                    '.bigtext * { white-space: nowrap; }',
                    // Added margin: 0 and padding: 0 to handle h1-h6 and p tags correctly
                    '.bigtext > * { display: block; margin: 0; padding: 0; box-sizing: border-box; }', 
                    '.bigtext .' + BigText.EXEMPT_CLASS + ', .bigtext .' + BigText.EXEMPT_CLASS + ' * { white-space: normal; }',
                    '@media (max-width: 639px) { .bigtext * { white-space: normal; } }'
                ];
                headCache.appendChild(BigText.generateStyleTag(BigText.GLOBAL_STYLE_ID, globalStyles));
            }
        },

        bindResize: function(eventName, id) {
            let timeoutId;

            if(BigText.resizeListeners[id]) {
                window.removeEventListener('resize', BigText.resizeListeners[id]);
            }
            
            const resizeFunction = () => {
                 if (timeoutId) {
                    clearTimeout(timeoutId);
                }
                timeoutId = setTimeout(() => {
                    const element = document.getElementById(id);
                    if(element) {
                        BigText.jQueryMethod.call(element, element.bigTextOptions);
                    }
                }, 100);
            };

            window.addEventListener('resize', resizeFunction);
            BigText.resizeListeners[id] = resizeFunction;
        },

        getStyleId: function(id) {
            return BigText.STYLE_ID + '-' + id;
        },

        generateStyleTag: function(id, css) {
            const style = document.createElement('style');
            style.id = id;
            style.textContent = css.join('\n');
            return style;
        },

        clearCss: function(id) {
            const styleId = BigText.getStyleId(id);
            const styleElement = document.getElementById(styleId);
            if (styleElement) {
                styleElement.remove();
            }
        },

        generateCss: function(id, linesFontSizes, lineWordSpacings, minFontSizes) {
            const css = [];
            BigText.clearCss(id);

            for (let j = 0, k = linesFontSizes.length; j < k; j++) {
                const lineSelector = '#' + id + ' .' + BigText.LINE_CLASS_PREFIX + j;
                let rules = '';
                if (minFontSizes[j]) {
                    rules += ' white-space: normal;';
                }
                if (linesFontSizes[j]) {
                    rules += ' font-size: ' + linesFontSizes[j] + 'px;';
                }
                if (lineWordSpacings[j]) {
                    rules += ' word-spacing: ' + lineWordSpacings[j] + 'px;';
                }
                if(rules) {
                    css.push(lineSelector + ' {' + rules + '}');
                }
            }

            return BigText.generateStyleTag(BigText.getStyleId(id), css);
        },
        
        jQueryMethod: function(options) {
            BigText.init();

            const element = this;

            // 1. Defaults
            const defaults = {
                minfontsize: BigText.DEFAULT_MIN_FONT_SIZE_PX,
                maxfontsize: BigText.DEFAULT_MAX_FONT_SIZE_PX,
                childSelector: '',
                resize: true
            };

            // 2. Data Attributes (parse them from the DOM element)
            // Attributes like data-maxfontsize="100" become element.dataset.maxfontsize
            const dataOptions = {};
            if (element.dataset) {
                if (element.dataset.maxfontsize) dataOptions.maxfontsize = Number(element.dataset.maxfontsize);
                if (element.dataset.minfontsize) dataOptions.minfontsize = Number(element.dataset.minfontsize);
                if (element.dataset.childSelector) dataOptions.childSelector = element.dataset.childSelector;
                if (element.dataset.resize) dataOptions.resize = element.dataset.resize === 'true';
            }

            // 3. Merge: Defaults < Data Attributes < Explicit Options
            options = Object.assign({}, defaults, dataOptions, options || {});

            element.classList.add('bigtext');
            element.bigTextOptions = options; 

            let id = element.id;
            if (!id) {
                id = 'bigtext-id' + (counter++);
                element.id = id;
            }

            const maxWidth = element.offsetWidth;
            const children = options.childSelector ? Array.from(element.querySelectorAll(options.childSelector)) : Array.from(element.children);

            if (options.resize) {
                BigText.bindResize('resize.bigtext-event-' + id, id);
            }

            BigText.clearCss(id);
            
            children.forEach((child, lineNumber) => {
                child.className = child.className.replace(new RegExp('\\b' + BigText.LINE_CLASS_PREFIX + '\\d+\\b'), '');
                child.classList.add(BigText.LINE_CLASS_PREFIX + lineNumber);
            });
            
            const sizes = BigText.calculateSizes(element, children, maxWidth, options.maxfontsize, options.minfontsize);
            headCache.appendChild(BigText.generateCss(id, sizes.fontSizes, sizes.wordSpacings, sizes.minFontSizes));

            element.dispatchEvent(new CustomEvent('bigtext:complete', { bubbles: true, cancelable: true }));
        },

        testLineDimensions: function(line, maxWidth, property, size, interval, units, previousWidth) {
            previousWidth = typeof previousWidth === 'number' ? previousWidth : 0;
            const styleProp = property.replace(/-([a-z])/g, (g) => g[1].toUpperCase());
            line.style[styleProp] = size + units;

            const width = line.offsetWidth;

            if (width >= maxWidth) {
                line.style[styleProp] = '';

                if (width === maxWidth) {
                    return {
                        match: 'exact',
                        size: parseFloat((parseFloat(size) - 0.1).toFixed(3))
                    };
                }

                const under = maxWidth - previousWidth;
                const over = width - maxWidth;

                return {
                    match: 'estimate',
                    size: parseFloat((parseFloat(size) - (property === 'word-spacing' && previousWidth && (over < under) ? 0 : interval)).toFixed(3))
                };
            }

            return width;
        },

        calculateSizes: function(element, children, maxWidth, maxFontSize, minFontSize) {
            const clone = element.cloneNode(true);
            clone.classList.add('bigtext-cloned');
            
            const elementStyle = window.getComputedStyle(element);

            Object.assign(clone.style, {
                fontFamily: elementStyle.fontFamily,
                textTransform: elementStyle.textTransform,
                wordSpacing: elementStyle.wordSpacing,
                letterSpacing: elementStyle.letterSpacing,
                position: 'absolute',
                left: BigText.DEBUG_MODE ? '0' : '-9999px',
                top: BigText.DEBUG_MODE ? '0' : '-9999px'
            });

            document.body.appendChild(clone);
            
            const clonedChildren = Array.from(clone.children);

            const fontSizes = [];
            const wordSpacings = [];
            const minFontSizes = [];
            const ratios = [];

            clonedChildren.forEach(line => {
                line.style.float = 'left';

                if (line.classList.contains(BigText.EXEMPT_CLASS)) {
                    fontSizes.push(null);
                    ratios.push(null);
                    minFontSizes.push(false);
                    return;
                }
                
                const intervals = BigText.supports.wholeNumberFontSizeOnly ? [8, 4, 1] : [8, 4, 1, 0.1];
                let lineMax;
                let newFontSize;

                const autoGuessSubtraction = 32;
                const currentFontSize = parseFloat(window.getComputedStyle(line).fontSize);
                const ratio = (line.offsetWidth / currentFontSize).toFixed(6);

                newFontSize = parseInt(maxWidth / ratio, 10) - autoGuessSubtraction;

                outer: for (let m = 0, n = intervals.length; m < n; m++) {
                    inner: for (let j = 1, k = 10; j <= k; j++) {
                        if (newFontSize + j * intervals[m] > maxFontSize) {
                            newFontSize = maxFontSize;
                            break outer;
                        }

                        lineMax = BigText.testLineDimensions(line, maxWidth, 'font-size', newFontSize + j * intervals[m], intervals[m], 'px', lineMax);
                        if (typeof lineMax !== 'number') {
                            newFontSize = lineMax.size;

                            if (lineMax.match === 'exact') {
                                break outer;
                            }
                            break inner;
                        }
                    }
                }

                ratios.push(maxWidth / newFontSize);

                if (newFontSize > maxFontSize) {
                    fontSizes.push(maxFontSize);
                    minFontSizes.push(false);
                } else if (!!minFontSize && newFontSize < minFontSize) {
                    fontSizes.push(minFontSize);
                    minFontSizes.push(true);
                } else {
                    fontSizes.push(newFontSize);
                    minFontSizes.push(false);
                }
            });

            clonedChildren.forEach((line, lineNumber) => {
                let wordSpacing = 0;
                const interval = 1;
                let maxWordSpacing;

                if (line.classList.contains(BigText.EXEMPT_CLASS)) {
                    wordSpacings.push(null);
                    return;
                }
                
                line.style.fontSize = fontSizes[lineNumber] + 'px';

                for (let m = 1, n = 3; m < n; m += interval) {
                    maxWordSpacing = BigText.testLineDimensions(line, maxWidth, 'word-spacing', m, interval, 'px', maxWordSpacing);
                    if (typeof maxWordSpacing !== 'number') {
                        wordSpacing = maxWordSpacing.size;
                        break;
                    }
                }
                
                line.style.fontSize = '';
                wordSpacings.push(wordSpacing);
            });
            
            clonedChildren.forEach(child => child.removeAttribute('style'));

            if (!BigText.DEBUG_MODE) {
                clone.remove();
            } else {
                clone.style.backgroundColor = 'rgba(255,255,255,.4)';
            }

            return {
                fontSizes: fontSizes,
                wordSpacings: wordSpacings,
                ratios: ratios,
                minFontSizes: minFontSizes
            };
        }
    };

    // Public API
    window.bigText = function(selector, options) {
        const elements = typeof selector === 'string' ? document.querySelectorAll(selector) : selector;
        if(!elements) return;
        
        const elementsArray = (elements.length === undefined) ? [elements] : Array.from(elements);
        
        elementsArray.forEach(element => {
            BigText.jQueryMethod.call(element, options);
        });
    };

    // Auto-initialize for IDs starting with "bigtext"
    document.addEventListener('DOMContentLoaded', function() {
        const autoElements = document.querySelectorAll('[id^="bigtext"]');
        autoElements.forEach(element => {
            // Options are parsed from data-attributes inside jQueryMethod
            BigText.jQueryMethod.call(element);
        });
    });

})(this);
  </script>
    {{site.customCode.bodyCode}}
    {{customCode.bodyCode}}
  </body>
</html>
